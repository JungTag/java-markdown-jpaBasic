# 고급 매핑



## 1. 상속관계 매핑

### 상속관계 매핑 및 전략

- 관계형 DB는 상속 관계 X

- 슈퍼타입-서브타입 관계라는 모델링 기법이 객체 상속과 유사

- 상속관계 매핑: 객체의 상속 구조와 DB의 슈퍼타입-서브타입 관계를 매핑

- 물리적으로 매핑하는 전략 3가지

  - 1) **각각 테이블로 전환 -> <u>조인 전략</u>** **(기본 전략)**

    - 부모 테이블을 만들고, 해당 테이블에 구별자를 넣음
    - 부모 테이블의 PK를 자식 테이블의 PK+FK로 가짐

  - 2. **통합 테이블로 변환 -> 단일 테이블 전략**

    - 부모 테이블 하나에 자식 테이블의 모든 프로퍼티를 다 넣음

  - 3. **서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략**

    - 부모 테이블을 없애고, 공통 프로퍼티를 각각의 테이블이 모두 갖고있는 형태
    - 조회 시 성능이 안좋음
      - 왜? 
      - 별도의 구분자가 없으므로 부모클래스 타입으로 조회하면 구현 클래스를 모두 조회하게 됨

- 어노테이션을 사용하여 구현

  - ```java
    @Inheritance(startegy=InheritanceType.XXX)
    ```

    - JOINED: 조인 전략
      - 객체 상속과 가장 유사한 형태
    - SINGLE_TABLE: 단일 테이블 전략
      - 성능이 좋음
    - TABLE_PER_CLASS: 구현 클래스마다 테이블 전략

  - ```java
    @DiscriminatorColumn(name="DTYPE")
    ```

    - 구분자 컬럼 생성, default로 DTYPE이 들어간다(하이버네이트 기준).
    - **넣어주는 게 좋음** -> 운영이나 조회 시 유리
    - 각 전략별로 다름
      - 1. **조인 전략에선 넣어줘야 생김** -> 테이블이 분리되어 있으므로
        2. **단일 테이블 전략에선 넣지 않아도 생김** -> 테이블이 하나이므로 구분자가 없으면 테이블 구분을 할 수 없으므로
        3. **구현 클래스마다 테이블 전략에선 넣어도 생기지 않음** -> 공통 프로퍼티를 지니고 있어 구분할 필요가 없으므로

  - ```java
    @DiscriminatorValue("XXX")
    ```

    - 구분자 컬럼 값에 인자를 할당, default로 Entity명이 들어감
      - 위 예제에선 DTYPE="XXX"



### 각 전략의 장단점

- **조인 전략**
  - 기본 전략으로 사용
  - 장점
    - 테이블 정규화
    - 제약조건을 공통 테이블에 걸어서 서브 테이블에 모두 적용할 수 있음
    - 외래 키 참조 무결성 제약조건 활용가능
    - 저장공간 효율화
  - 단점
    - 조회 시 조인을 많이 사용
      - 성능 저하 -> 조인 쿼리를 잘 쓰면 오히려 더 빠름
      - 조회 쿼리가 복잡함
    - 데이터 저장 시 INSERT SQL 2번 호출 -> 그렇게 큰 단점은 아님, 단일 테이블에 비해 복잡하다는 뜻
- **단일 테이블 전략**
  - 테이블이 매우 단순할 때 사용
  - 장점
    - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
    - 조회 쿼리가 단순함
  - 단점
    - 자식 엔티티가 매핑한 컬럼은 모두 null 허용
    - 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있음 -> 상황에 따라 조회 성능이 오히려 느려질 수 있다.
- **구현 클래스마다 테이블 전략**
  - 쓰면 안되는 전략 (DB 설계자와 ORM 전문가 모두가 추천 X)
  - 장점
    - 서브 타입 명확하게 구분해서 처리할 때 효과적 -> INSERT SQL에 유리
    - not null 제약조건 사용 가능
  - 단점
    - 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL)
    - 자식 테이블을 통합해서 쿼리하기 어려움



## 2. 매핑 정보 상속

### @MappedSuperclass

- 공통 매핑 정보가 필요할 때 사용
  - **DB는 별개인데 객체 입장에서 동일한 속성을 적용하고 싶을 때**
  - 부모 클래스에 어노테이션 사용
- 상속관계 매핑X
- 엔티티X, 즉 테이블과 매핑되지 않음 -> 별도의 테이블이 생성되지 않음
  - 부모 클래스를 상속받는 **자식 클래스에 매핑 정보만 제공** -> **자식 클래스에 공통속성만 추가**
- 조회, 검색 불가 -> **em.find(BaseEntity) 불가**
- 직접 생성해서 사용할 일이 없으므로 **추상 클래스 권장**
- **역할**
  - 테이블과 관계 없고 단순히 엔티티가 공통으로 사용하는 매핑정보를 모으는 역할
  - 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용
  - 참고: @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능
    - 상속 대상이 되는 부모클래스는 @Entity 또는 @MappedSuperclass로 한정