# 프록시와 연관관계 관리



## 1. 프록시

### 프록시 기초

- em.find() vs em.getReference()
  - **em.find()**: DB를 통해서 실제 엔티티 객체 조회
  - **em.getReference()**: DB 조회를 미루는 **가짜(프록시) 엔티티 객체 조회**
- **기본 특징**
  - 실제 클래스를 상속받아서 만들어짐
  - 실제 클래스와 겉모양이 같다
  - 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨(이론상)
  - 프록시 객체는 실제 객체의 참조(target)를 보관
  - 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출

### 프록시 객체의 초기화

```java
Member member = em.getReference(Member.class, "id1");
member.getName();
```

1. getName() 호출
2. 영속성 컨텍스트에 초기화 요청
3. DB조회
4. 실제 Entity 생성 후 target에 할당(초기화)
5. target.getName() 호출

### 프록시 특징

- 프록시 객체는 처음 사용할 때 한 번만 초기화 -> 한 번만 초기화하고 해당 객체를 계속 사용
- 프록시 객체를 초기화할 때 프록시 객체가 실제 엔티티로 바뀌는 것은 아님
  - 초기화 후에 프록시 객체를 통해서 실제 엔티티에 접근 가능
  - **<u>프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의</u>**해야 함 -> **== 비교 실패, 대신 Instance of 사용**
- <u>**영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환**</u>
  - 반대로 em.getRefence()를 먼저 호출하고 em.find()를 호출하면 프록시 객체 반환
  - 중요한 것은 **하나의 트랜잭션 안에선 조회를 통해 반환되는 객체를 동일하게 맞춘다**는 것!!
- **<u>영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생</u>**
  - 하이버네이트는 org.hibernate.LazyInitializationException 예외를 터트림

### 프록시 확인

- 프록시 인스턴스의 초기화 여부 확인

  - ```java
    PersistenceUnitUtil.isLoaded(Object entity)
    ```

- 프록시 클래스 확인 방법

  - ```java
    entity.getClass().getName() 출력 (..javasist.. or HibernateProxy)
    ```

- 프록시 강제 초기화

  - ```java
    org.hibernamte.Hibernate.initialize(entity);
    ```

- 참고: JPA표준은 강제 초기화 없음

  - 강제호출: member.getName()



## 2. 지연 로딩과 즉시 로딩

### 지연 로딩

- 연관된 엔티티를 조회할 때 프록시 객체를 가져오는 것
- **실제 연관 엔티티를 사용하는 시점에 초기화**(DB 쿼리 발생)
- 연관 엔티티를 자주 사용하지 않는 경우 사용

### 즉시 로딩

- 연관된 엔티티를 조회할 때 DB쿼리를 날려 실제 객체를 가져오는 것
- JPA 구현체는 가능하면 조인을 사용해서 SQL 한번에 함께 조회
- 연관 엔티티를 자주 사용하는 경우 사용 -> 실무에선 사용 X, 성능을 고려하지 않는 아주 작은 프로젝트에서만

### 프록시와 즉시로딩 주의

- **가급적 지연 로딩만 사용** (특히 실무에서!!)
- 즉시 로딩을 적용하면 예상하지 못한 SQL 발생
- **즉시 로딩은 JPQL에서 N+1문제를 일으킨다.**
- **@ManyToOne, @OneToOne은 기본이 즉시 로딩 -> LAZY로 설정**
- @OneToMany, @ManyToMany는 기본이 지연 로딩

### 지연로딩 활용 - 실무

- **<u>모든 연관관계에 지연로딩을 사용해라!</u>**
- **<u>실무에서 즉시로딩을 사용하지마라!</u>**
- JPQL fetch 조인이나 엔티티 그래프 기능을 사용해라!
- 즉시 로딩은 상상하지 못한 쿼리가 나간다.



## 3. 영속성 전이(CASCADE)와 고아 객체

### 영속성 전이: CASCADE

- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속상태로 만들고 싶을 때

  - e.g. 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장
- CASCADE의 종류

  - **ALL: 모두 적용**
  - **PERSIST: 영속**
  - **REMOVE: 삭제**
  - MERGE: 병합
  - REFRESH: REFRESH
  - DETACH: DETACH
- **주의사항 - 사용이 제한적**
  - 라이프사이클이 똑같을 때 (부모-자식)
  - 단일 소유자일 때 = 단일 엔티티에 완전히 종속적인 경우에만 사용

### 고아 객체

- 고아 객체 제거: 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제

- **orphanRemoval = true**

- ```java
  Parent parent1 = em.find(Parent.class, id);
  parent1.getChildren().remove(0); // 자식 엔티티를 컬렉션에서 제거
  ```

- ```sql
  DELETE FROM CHILD WHERE ID = ?
  ```

- **주의사항**
  - 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능
  - **참조하는 곳이 하나일 때 사용해야 함!**
  - **특정 엔티티가 개인 소유할 때 사용**
  - @OneToOne, @OneToMany만 가능
  - 참고
    - 개념적으로 부모를 제거하면 자식은 고아가 된다.
    - 따라서 고아 객체 제거 기능을 활성화하면, 부모를 제거할 때 자식도 함께 제거된다.
    - CascadeType.REMOVE처럼 동작

### 영속성 전이 + 고아 객체, 생명주기

- **CascadeType.ALL + orphanRemoval=true**
- 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거
- 두 옵션을 모두 활성화하면 부모 엔티티를 통해서 자식 엔티티의 생명주기를 관리할 수 있음
- 도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용